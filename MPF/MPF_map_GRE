#!/usr/bin/env python3

import argparse
import base64
import logging
import math
import re
import sys

import dicomifier
import nibabel
import numpy
import scipy.integrate
import scipy.optimize

import argument_parsers
import pyximport; pyximport.install()
import mpf

def qmti_map(image1, image2, B0_map, B1_map, T1_map, MTR_path, MPF_path):
    """ qMTI map """
    
    # Read MT data
    FA = []
    TR = []
    for image, meta_data in [image1, image2]:    
        
        FA.append(math.radians(meta_data['FlipAngle'][0])) # [rad]
        TR.append(meta_data['RepetitionTime'][0]*1e-3) # [s]
        
        data = image.get_data().astype(numpy.float32)
        
        MT_FA_tmp = math.radians(get_pulse_info(meta_data, "FA"))
        if MT_FA_tmp < numpy.pi/2:
            Smt0 = data[...,0]
        else:
            Smt = data[...,0]
            MT_FA = MT_FA_tmp # [rad]
            MT_length = get_pulse_info(meta_data, "length")*1e-6 # [s]
            MT_offset = get_pulse_info(meta_data, "offset") # [Hz]
                
    if TR[0] != TR[1]:
        raise Exception ('TR are different: {}'.format(TR))
    if FA[0] != FA[1]:
        raise Exception ('FA are different: {}'.format(FA))
    
    logging.debug('FA: {} degrees'.format(numpy.degrees(FA)))
    logging.info('MT FA: {} degrees'.format(numpy.degrees(MT_FA)))
    logging.info('MT length: {} s'.format(MT_length))
    logging.info('MT offset: {} Hz'.format(MT_offset))
        
    S_ratio = Smt/Smt0
    
    # Compute MTR if required
    if MTR_path is not None:
        MTR = (Smt0 - Smt) / Smt0 * 100 # [%]
        MTR = nibabel.Nifti1Image(MTR, image1[0].affine)
        nibabel.save(MTR, MTR_path)

    # Loading datas ...
    
    # ... B1 map
    B1map = B1_map.get_data().astype(numpy.float32)*1e-2 # [%]
    
    # ... T1 map
    T1map = T1_map.get_data().astype(numpy.float32) # [s]
    R1 = 1/T1map # [s^-1]
    T2f = 0.022*T1map # [s]
    
    # ... B0 map
    B0map = B0_map.get_data().astype(numpy.float32) # [Hz]
    df = numpy.round(MT_offset - B0map) # [Hz]
    
    if not all(x.shape == Smt.shape for x in [B1map, T1map, B0map]):
        raise Exception("Image shape mismatch")
    
    # Calculate the MPF map ...
    f0 = 0.10
    G_tmp = estimate_G_superLorentzian() 
    G = lorentzian_shape(G_tmp, df)
       
    w1rms_nominal = w1rms_gaussian_pulse(MT_length, MT_FA)   
    w1rms = w1rms_nominal * B1map
    logging.debug("w1rms_nominal = {}".format(w1rms_nominal))
    logging.debug("min w1rms = {}".format(numpy.min(w1rms)))
    logging.debug("max w1rms = {}".format(numpy.max(w1rms)))
    
    # ... by estimating the f value on each voxel for the model.
    f = estimate_f_map(R1, T2f, MT_length, df, TR, FA, w1rms, G, S_ratio, f0)
    
    MPF = nibabel.Nifti1Image(f*1e2, image1[0].affine) # [%]
    nibabel.save(MPF, MPF_path)


def get_pulse_info(meta_data, info):
    """ Read the MT pulse informations from the private data. """    
    
    protocol = dicomifier.dicom_to_nifti.siemens.parse_csa(
            base64.b64decode(meta_data["00291020"][0]))["MrPhoenixProtocol"][0]

    if info == "FA":
        pulse_info = float(re.search(br"sWiPMemBlock.alFree\[4\]\s*=\s*(\S+)$", protocol, re.M).group(1))
    elif info == "length":
        pulse_info = float(re.search(br"sWiPMemBlock.alFree\[5\]\s*=\s*(\S+)$", protocol, re.M).group(1))
    elif info == "offset":
        pulse_info = float(re.search(br"sWiPMemBlock.alFree\[6\]\s*=\s*(\S+)$", protocol, re.M).group(1))
    
    return pulse_info


def estimate_G_superLorentzian():
    """ Quantitative Magnetization Transfer Imaging Made Easy with q MTL ab: 
        Software for Data Simulation, Analysis, and Visualization [Eq. 7] """
    
    T2b = 11e-6
    nDelta = 1e4
    G = []

    for i in range(1,int(nDelta)+1):
        tmp = T2b * numpy.sqrt(2/numpy.pi) * float(
                scipy.integrate.quad(mpf.int_superLorentzian, 0, 1, args=(i, T2b))[0])
        G.append(float(tmp))
        
    return G

def lorentzian_shape(G, df):
    """ Estimation of the value of the G parameter, representing the shape,
        according to the frequency. """

    size = df.shape
    dim = 1

    for i in range(0, len(size)):
        dim = dim*size[i]
        
    df_vector = numpy.reshape(df, dim)
    
    tmp = []
    for i in range(0, len(df_vector)):
        tmp.append(G[int(df_vector[i])-1])

    return numpy.reshape(tmp, df.shape)
    

def w1rms_gaussian_pulse(tm, MT_FA):
    """ Estimation of the saturation pulse, w1rms. 
        Fast Macromolecular Proton Fraction Mapping from A Single Off-Resonance 
        Magnetization Transfer Measurement. Yarnykh, 2012 [Eq. 4]"""
    
    gammaH = 2*numpy.pi*42.57e6 # [rad*Hz/T]
    max_gaussian = -scipy.optimize.minimize_scalar(
            lambda t: -gaussian_pulse(t,tm), bounds=(0, tm), method='bounded'
        ).fun
    
    int_b1 = float(
        scipy.integrate.quad(
            lambda t: gaussian_pulse(t, tm)/max_gaussian, 0, tm
        )[0])
    alpha = gammaH * int_b1
    int_b1_square = float(
        scipy.integrate.quad(
            lambda t: gaussian_pulse(t, tm)**2/max_gaussian**2, 0, tm
        )[0])
    b1rms = numpy.sqrt( int_b1_square / tm ) 
    
    w1rms = gammaH * b1rms * MT_FA / alpha
    
    return w1rms


def gaussian_pulse(t, tm):

    alpha = 0.5 # for a Hanning window
    Emp = 1 # default value
    
    w = (1-alpha) + alpha*numpy.cos(2*numpy.pi*t/tm)
    b1 = w * (numpy.exp(-numpy.pi*Emp*t))**2 / (4 * numpy.log(2) )
    
    return b1

def estimate_f_map(R1, T2f, MT_length, df, TR, FA, w1rms, G, S_ratio, f0):
    """ Computation of the f map, which is the optimizatiofunn of the loss 
        fonction, ie. where the signal ratio moves towards the model 
        estimated. """

    f = numpy.zeros(R1.shape)
    iterator = numpy.nditer(
        [R1, T2f, df, w1rms, G, S_ratio, f], 
        ["f_index", "multi_index"], 
        6*[["readonly"]]+[["writeonly"]])
    
    for operands in iterator:
        args = dict(
            zip(["R1", "T2f", "df", "w1rms", "G", "S_ratio", "f"], operands))
    
        result = scipy.optimize.fsolve(
            mpf.model, f0, 
            (
                args["R1"], args["T2f"], MT_length, args["df"], TR, FA, 
                args["w1rms"], args["G"], args["S_ratio"]))
        iterator[-1] = result[0]
    
    return f

if __name__ == "__main__":

    parser = argparse.ArgumentParser(
        description="Compute an MPF map from GRE images; based on"
            "Time-efficient, high-resolution, whole brain three-dimensional "
            "macromolecular proton fraction mapping, Yarnykh, MRM 2015")
    
    parser.add_argument(
        "image1", type=argument_parsers.image_and_meta_data_type,
        help="Path to a GRE image (magnitude, with or without MT pulse)")
    parser.add_argument(
        "image2", type=argument_parsers.image_and_meta_data_type,
        help="Path to a GRE image (magnitude, with or without MT pulse)")
    parser.add_argument(
        "B0_map", type=argument_parsers.image_type, 
        help="Path to the B0 map (in the same voxel space as the GRE)")
    parser.add_argument(
        "B1_map", type=argument_parsers.image_type, 
        help="Path to the B1 map (in the same voxel space as the GRE)")
    parser.add_argument(
        "T1_map", type=argument_parsers.image_type, 
        help="Path to the T1 map (in the same voxel space as the GRE)")
    parser.add_argument("MPF_path", metavar="MPF", help="Path to the MPF map")
    parser.add_argument("--mtr", dest="MTR_path", help="Path to the MTR map")
    parser.add_argument(
        "-v", "--verbose", 
        default = 'warning', choices=["debug", "info", "warning"],
        metavar="LEVEL", help="Logging level (default: warning)")
    args = vars(parser.parse_args())
    
    logging.basicConfig(level=args.pop('verbose').upper())
    
    numpy.seterr(divide="ignore", invalid="ignore")
    
    try: 
        sys.exit(qmti_map(**args))
    except Exception as e:
        if logging.getLogger().getEffectiveLevel() <= logging.DEBUG:
            raise
        else:
            parser.error(e)
