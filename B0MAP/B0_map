#!/usr/bin/env python3

import argparse
import logging
import os
import sys

import nibabel
import numpy

sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
import argument_parsers


def b0_map(GRE, output):
    """B0 map generation"""
    
    # Read MT datas
    TE = []
    S_phase = []
    S_mag = []
    for image, meta_data in GRE:
        image_type = meta_data['ImageType'][2]
        TE.extend([x[0] for x in meta_data["EchoTime"]]) # [ms]
        
        tmp = image.get_data().astype(numpy.float32)
        if image_type == "P":
            tmp = tmp / 4096 * numpy.pi
            S_phase.append(tmp[:,:,:,0])
            S_phase.append(tmp[:,:,:,1])
        elif image_type is "M":
            S_mag.append(tmp[:,:,:,0])
            S_mag.append(tmp[:,:,:,1])
        else:
            raise Exception('Wrong ImageType: {}'.format(image_type))

    if TE[0] != TE[2] or TE[1] != TE[3]:
        raise Exception('TE are differents: {}'.format(TE))
    
    logging.debug("Echo times: {} ms".format(TE[:2]))
               
    # Calculate the B0 map
    Z = [m*numpy.exp(1j*p) for m, p in zip(S_mag, S_phase)]
    Zc = numpy.conjugate(Z)
    
    phi_B0 = numpy.arctan2( numpy.imag(Z[1]*Zc[0]), numpy.real(Z[1]*Zc[0]) )
    
    delta_TE = (TE[1] - TE[0])*1e-3 # in s
    logging.debug("delta TE: {} s".format(delta_TE))
    
    img_B0 = phi_B0 / (2*numpy.pi*delta_TE)
           
    oimg = nibabel.Nifti1Image(img_B0, GRE[0][0].affine)
    nibabel.save(oimg, output)  


if __name__ == "__main__":

    parser = argparse.ArgumentParser(
        description="Compute a map of B0 from a set of GRE images at "
            "different echo times")
    
    parser.add_argument(
        "GRE", type=argument_parsers.image_and_meta_data_type, nargs=2, 
        help="Path to the GRE images (magnitude and phase, in any order)")
    parser.add_argument("output", help="Path to the B0 map")
    parser.add_argument(
        "-v", "--verbose", 
        default = 'warning', choices=["debug", "info", "warning"],
        metavar="LEVEL", help="Logging level (default: warning)")
    args = vars(parser.parse_args())
    
    logging.basicConfig(level=args.pop('verbose').upper())

    try:
        sys.exit(b0_map(**args))
    except Exception as e:
        if logging.getLogger().getEffectiveLevel() <= logging.DEBUG:
            raise
        else:
            parser.error(e)
