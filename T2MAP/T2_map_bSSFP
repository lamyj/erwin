#!/usr/bin/env python3

import argparse
import base64
import json
import logging
import math
import re
import sys

import dicomifier
import nibabel
import numpy

import argument_parsers

import scipy.ndimage.filters

def t2_map(bSSFP, rB1_map, T1_map, output):
    """T2 map generation"""
   
    # Loading B1 map, T1 map and T1w data
    data_rB1 = rB1_map.get_data().astype(numpy.float32)*1e-2 
    data_rB1[data_rB1<0.10] = numpy.nan
    
    data_T1 = T1_map.get_data().astype(numpy.float32)
    
    # Reading bSSFP datas
    FA = [] # [Â°]
    TR = [] # [s]
    TE = [] # [s]
    phi = []
    for _, meta_data in bSSFP:
        FA.append(meta_data['FlipAngle'][0]) 
        TR.append(meta_data['RepetitionTime'][0]*1e-3)
        TE.append(meta_data['EchoTime'][0]*1e-3)
        phi.append(get_phase_increment(meta_data))
                
    if TR[0] != TR[1] != TR[2] != TR[3] != TR[4] != TR[5] != TR[6] != TR[7]:
        raise Exception('TR are differents: {}'.format(TR))
    if TE[0] != TE[1] != TE[2] != TE[3] != TE[4] != TE[5] != TE[6] != TE[7]:
        raise Exception('TE are differents: {}'.format(TE))
    
    logging.debug('FA = {} degrees'.format(FA))
    logging.info('TR = {} ms'.format(phi))
    logging.info('TE = {} ms'.format(phi))
    logging.info('phi = {}'.format(phi))
        
    S = [img[0].get_data().astype(numpy.float32) for img in bSSFP]
    S_filtered = [ scipy.ndimage.filters.median_filter(s, size=(2,2,2)) for s in S ]
    
    x = S[0].shape
    tau = numpy.zeros((x[0], x[1], x[2], 8))
    E1 = numpy.exp(-TR[0]/data_T1)

    for i in range(0,len(S),2):    
        X1 = S[i]/numpy.tan(numpy.radians(FA[i]*data_rB1))
        X2 = S[i+1]/numpy.tan(numpy.radians(FA[i+1]*data_rB1))
        
        Y1 = S[i]/numpy.sin(numpy.radians(FA[i]*data_rB1))
        Y2 = S[i+1]/numpy.sin(numpy.radians(FA[i+1]*data_rB1))

        m = (Y2 - Y1)/(X2 - X1)
        n = (m - E1)/(m*E1 - 1)
        n[n<0] = numpy.nan
        tau[:,:,:,i] = -TR[0]/numpy.log(n)
        
    T2_map = numpy.sqrt(8/(3*4))*numpy.sqrt(numpy.nansum(numpy.power(tau,2),3)) 
    T2_map[data_T1 == 0] = numpy.nan
            
    oimg = nibabel.Nifti1Image(T2_map*1e3, bSSFP[0][0].affine) # [ms]
    nibabel.save(oimg, output)

    
def get_phase_increment(meta_data):
    """ Read the phase increment from the private data. """    

    protocol = dicomifier.dicom_to_nifti.siemens.parse_csa(
            base64.b64decode(meta_data["00291020"][0]))["MrPhoenixProtocol"][0]
    phase_increment = float(re.search(
                    br"sWiPMemBlock.alFree\[5\]\s*=\s*(\S+)$", protocol, re.M).group(1))
    
    return phase_increment


if __name__ == "__main__":

    parser = argparse.ArgumentParser(
        description="Compute a map of T2 from bSSFP images; based on "
            "Analytical corrections of banding artifacts in driven equilibrium "
            "single pulse observation of T2 (DESPOT2), "
            "Jutras et al., MRM2015.")
    
    parser.add_argument(
        "bSSFP", type=argument_parsers.image_and_meta_data_type, nargs=8,
        help="Path to the bSSFP images (in any order)")
    parser.add_argument(
        "rB1_map", type=argument_parsers.image_type,
        help="Path to the B1 map (in the same voxel space as the bSSFP)")
    parser.add_argument(
        "T1_map", type=argument_parsers.image_type,
        help="Path to the T1 map")
    parser.add_argument("output", help="Path to the T2 map")
    parser.add_argument(
        "-v", "--verbose", 
        default = 'warning', choices=["debug", "info", "warning"],
        metavar="LEVEL", help="Logging level (default: warning)")
    args = vars(parser.parse_args())
    
    logging.basicConfig(level=args.pop('verbose').upper())
    
    numpy.seterr(divide="ignore", invalid="ignore")
    
    try: 
        sys.exit(t2_map(**args))
    except Exception as e:
        if logging.getLogger().getEffectiveLevel() <= logging.DEBUG:
            raise
        else:
            parser.error(e)
