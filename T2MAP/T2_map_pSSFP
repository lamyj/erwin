#!/usr/bin/env python3

import argparse
import base64
import logging
import math
import re
import sys

import dicomifier
import nibabel
import numpy

sys.path.insert(0, '..')
import argument_parsers


def t2_map(pSSFP, B1_map, output):
    """T2 map generation"""
   
    data_rB1 = B1_map.get_data().astype(numpy.float32)*1e-2 
    
    # Read pSSFP datas
    FA = []
    TR = []
    phi = []
    xi = []
    S = {}
    
    for _, meta_data in pSSFP:
        FA.append(meta_data['FlipAngle'][0]) # [degrees]
        TR.append(meta_data['RepetitionTime'][0]*1e-3) # [s]
        phi.append(get_phase_increment(meta_data))
        
        xi.append(calculate_xi(FA[-1]))
    
    if FA[0] != FA[1]:
        raise Exception('FA are differents: {}'.format(FA))
    if TR[0] != TR[1]:
        raise Exception('TR are differents: {}'.format(TR))
    if phi[0] == phi[1]:
        raise Exception('Phases are similar: {}'.format(phi))
    
    logging.debug('FA = {} degrees'.format(FA))
    logging.info('phi = {}'.format(phi))
    logging.info('xi = {}'.format(xi))
    
    # Compute T2map  
    S = [x[0].get_data().astype(numpy.float32) for x in pSSFP]
    
    FA = FA[0]*data_rB1
    xi = calculate_xi(FA)
    
    T1_global = 1.25
    
    # NOTE: the formula is the same if the order of the images is reversed.
    A = ( S[0]**2 - S[1]**2 ) / ( S[1]**2 * phi[1]**2 - S[0]**2 * phi[0]**2 )    
    T2_est = 2*TR[0]*numpy.sqrt(A)/xi    
    T2_map = numpy.absolute( T2_est / (1 - 3/2 * calculate_eta(FA) * T2_est / T1_global) )
        
    oimg = nibabel.Nifti1Image(T2_map, pSSFP[0][0].affine)
    nibabel.save(oimg, output)

    
def get_phase_increment(meta_data):
    """ Read the phase increment from the private data. """    

    protocol = dicomifier.dicom_to_nifti.siemens.parse_csa(
            base64.b64decode(meta_data["00291020"][0]))["MrPhoenixProtocol"][0]
    phase_increment = float(re.search(
                    br"sWiPMemBlock.alFree\[5\]\s*=\s*(\S+)$", protocol, re.M).group(1))
    
    return phase_increment


def calculate_eta(FA):
    """ Estimate eta parameter according to flip angle value (in degrees). """
    
    FA_rad = FA*math.pi/180
    return 0.5 * (1 + numpy.cos(FA_rad)) / (1 - numpy.cos(FA_rad))
    

def calculate_xi(FA):
    """ Estimate Xi parameter according to flip angle value (in degrees). """    
#    "Steady State of Gradient Echo Sequences with Radiofrequency Phase Cycling: 
#    Analytical Solution, Contrast Enhancement with Partial Spoiling" (Table 1)

    N = 10
    eta = calculate_eta(FA)    
    xi = eq_c(eta, N)
    
    for k in range(N-1, -1, -1):
        xi = eq_a(eta, k) + eq_b(eta, k+1) / xi
        
    return xi*math.pi/180


def eq_a(eta, k):
    return (2*k + 1) * (eta + 1)

def eq_b(eta, k):   
    return -numpy.power(eta,2) * numpy.power(k,2) 

def eq_c(eta, k):
    return eq_a(eta, k) + eq_b(eta, k+1) / eq_a(eta, k+1)

    
if __name__ == "__main__":

    parser = argparse.ArgumentParser(
        description="Compute a map of T2 from pSSFP images; based on "
            "Factors controlling T2 mapping from partially spoiled SSFP "
            "sequence: Optimization for skeletal muscle characterization, "
            "de Sousa et al., MRM 2012.")
    
    parser.add_argument(
        "pSSFP", type=argument_parsers.image_and_meta_data_type, nargs=2,
        help="Path to the pSSFP images (in any order)")
    parser.add_argument(
        "B1_map", type=argument_parsers.image_type,
        help="Path to the B1 map (in the same voxel space as the pSSFP)")
    parser.add_argument("output", help="Path to the T2 map")
    parser.add_argument(
        "-v", "--verbose", 
        default = 'warning', choices=["debug", "info", "warning"],
        metavar="LEVEL", help="Logging level (default: warning)")
    args = vars(parser.parse_args())
    
    logging.basicConfig(level=args.pop('verbose').upper())
    
    numpy.seterr(divide="ignore", invalid="ignore")
    
    try: 
        sys.exit(t2_map(**args))
    except Exception as e:
        if logging.getLogger().getEffectiveLevel() <= logging.DEBUG:
            raise
        else:
            parser.error(e)
